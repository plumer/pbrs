use std::{
    f64::consts::{FRAC_1_PI, PI},
    io::Read,
};

/*
  File format description:

  This is the file format generated by the material designer of the paper

  'A Comprehensive Framework for Rendering Layered Materials' by
  Wenzel Jakob, Eugene D'Eon, Otto Jakob and Steve Marschner
  Transactions on Graphics (Proceedings of SIGGRAPH 2014)

  A standalone Python plugin for generating such data files is available
  on GitHub: https://github.com/wjakob/layerlab

  This format specifies an isotropic BSDF expressed in a Spline x Fourier
  directional basis. It begins with a header of the following type:

 struct Header {
     uint8_t identifier[7];     // Set to 'SCATFUN'
     uint8_t version;           // Currently version is 1
     uint32_t flags;            // 0x01: file contains a BSDF, 0x02: uses harmonic extrapolation
     int nMu;                   // Number of samples in the elevational discretization

     int nCoeffs;               // Total number of Fourier series coefficients stored in the file
     int mMax;                  // Coeff. count for the longest series occurring in the file
     int nChannels;             // Number of color channels (usually 1 or 3)
     int nBases;                // Number of BSDF basis functions (relevant for texturing)

     int nMetadataBytes;        // Size of descriptive metadata that follows the BSDF data
     int nParameters;           // Number of textured material parameters
     int nParameterValues;      // Total number of BSDF samples for all textured parameters
     float eta;                 // Relative IOR through the material (eta(bottom) / eta(top))

     float alpha[2];            // Beckmann-equiv. roughness on the top (0) and bottom (1) side
     float unused[2];           // Unused fields to pad the header to 64 bytes
 };

  Due to space constraints, two features are not currently implemented in PBRT,
  namely texturing and harmonic extrapolation (though it would be straightforward
  to port them from Mitsuba.)
*/

#[derive(Debug, Clone, Copy)]
#[repr(C, packed)]
struct FourierBsdfHeader {
    pub identifier: [u8; 7],
    pub version: u8,
    pub flags: u32,
    pub n_mu: i32,
    pub n_coeffs: i32,
    pub m_max: i32,
    pub n_channels: i32,
    pub n_bases: i32,
    pub n_metadata_bytes: i32,
    pub n_parameters: i32,
    pub n_parameter_values: i32,
    pub eta: f32,

    pub alpha: [f32; 2],
    pub unused: [f32; 2],
}

fn read_header(buffer: &[u8]) -> Result<FourierBsdfHeader, std::io::Error> {
    assert_eq!(std::mem::size_of::<FourierBsdfHeader>(), 64);

    let mut header: FourierBsdfHeader = unsafe { std::mem::zeroed() };
    unsafe {
        let header_slice = std::slice::from_raw_parts_mut(&mut header as *mut _ as *mut u8, 64);
        let mut buffer: &[u8] = &buffer;
        buffer.read_exact(header_slice).unwrap();
    }

    // Verification
    let identifier = buffer[0..7].iter().map(|&c| c as char).collect::<String>();
    assert_eq!(identifier, "SCATFUN");
    assert_eq!(header.version, 1);
    let flags = header.flags;
    assert_eq!(flags, 1);
    assert!(header.eta.is_finite());
    assert!(header.alpha[0].is_finite());
    assert!(header.alpha[1].is_finite());
    // println!("read structure: {:#?}", header);

    Ok(header)
}

#[derive(Default, Debug)]
pub struct FourierTable {
    pub m_max: usize,
    pub n_channels: usize, // Either 1 (monochromatic) or 3 (luminance, red and blue)
    // pub n_mu: usize,
    pub mu: Vec<f32>, // Set of discretized zenith angles (theta, angle between w and +Z)
    pub cdf: Vec<f32>,
    a0: Vec<f32>, // A cache of order-0 coefficients.
    pub a_offset: Vec<i32>,
    // A lookup table for the number of terms (m) to sum up a_k*cos(phi k). The order m can be
    // determined by querying m_lookup using 2 cos_theta (aka mu) values.
    pub m_lookup: Vec<i32>,
    pub a: Vec<f32>,
    pub recip: Vec<f32>,
}

impl FourierTable {
    pub fn build(
        n_channels: usize, mu: Vec<f32>, cdf: Vec<f32>, a_offset: Vec<i32>, m_lookup: Vec<i32>,
        coefficients: Vec<f32>,
    ) -> Self {
        assert!(n_channels == 1 || n_channels == 3);
        assert_eq!(mu.len().pow(2), cdf.len());
        assert_eq!(mu.len().pow(2), a_offset.len());
        assert_eq!(mu.len().pow(2), m_lookup.len());
        let m_max = *m_lookup.iter().max().unwrap() as usize;
        let a0 = (a_offset.iter().zip(m_lookup.iter()))
            .inspect(|(&offset, &length)| {
                let end = offset as usize + length as usize * n_channels;
                assert!(end <= coefficients.len());
            })
            .map(|(&offset, &length)| {
                if length > 0 {
                    coefficients[offset as usize]
                } else {
                    0.0
                }
            })
            .collect::<Vec<_>>();
        let recip = (0..m_max).map(|i| (i as f32).recip()).collect::<Vec<_>>();
        FourierTable {
            m_max,
            n_channels,
            mu,
            cdf,
            a0,
            a_offset,
            m_lookup,
            a: coefficients,
            recip,
        }
    }

    pub fn get_weights_and_offset(&self, cos_theta: f32) -> Option<(usize, [f32; 4])> {
        math::spline::catmull_rom_weights(&self.mu, cos_theta)
    }

    pub fn get_ak(&self, offset_i: usize, offset_o: usize) -> (&[f32], usize) {
        let index = offset_o * self.mu.len() + offset_i;
        let m = self.m_lookup[index] as usize;
        (&self.a[index..index + m * self.n_channels], m)
    }

    pub fn from_file(path: &str) -> Result<FourierTable, std::io::Error> {
        let mut file = std::fs::File::open(path)?;
        let mut header_buffer = [0u8; 64];
        file.read_exact(&mut header_buffer)?;
        let header = read_header(&header_buffer)?;
        let n_mu = header.n_mu as usize;
        let n_coeffs = header.n_coeffs as usize;

        let read_n_f32s = |n: usize| {
            let mut whole_buffer = vec![0u8; 4 * n];
            (&file).read_exact(&mut whole_buffer).unwrap();
            (0..n)
                .map(|i| {
                    let slice = &whole_buffer[4 * i..4 * i + 4];
                    let bytes = [slice[0], slice[1], slice[2], slice[3]];
                    f32::from_ne_bytes(bytes)
                })
                .collect::<Vec<_>>()
        };
        let read_n_i32s = |n: usize| {
            let mut whole_buffer = vec![0u8; 4 * n];
            (&file).read_exact(&mut whole_buffer).unwrap();
            (0..n)
                .map(|i| {
                    let slice = &whole_buffer[4 * i..4 * i + 4];
                    let bytes = [slice[0], slice[1], slice[2], slice[3]];
                    i32::from_ne_bytes(bytes)
                })
                .collect::<Vec<_>>()
        };
        let mu = read_n_f32s(n_mu);
        for i in 0..mu.len() - 1 {
            assert!(mu[i] <= mu[i + 1]);
        }
        let cdf = read_n_f32s(n_mu * n_mu);
        let offset_and_length = read_n_i32s(n_mu * n_mu * 2);
        let a = read_n_f32s(n_coeffs);

        let mut a_offset = Vec::with_capacity(n_mu * n_mu);
        let mut m = Vec::with_capacity(n_mu * n_mu);
        for chunk in offset_and_length.chunks(2) {
            if let &[offset, length] = chunk {
                a_offset.push(offset);
                m.push(length);
            }
        }
        println!("raw data ready");
        let table = FourierTable::build(header.n_channels as usize, mu, cdf, a_offset, m, a);
        Ok(table)
    }
}


#[test]
fn read_header_test() {
    let buffer = [
        0x53, 0x43, 0x41, 0x54, 0x46, 0x55, 0x4e, 0x01, // identifier and version
        0x01, 0x00, 0x00, 0x00, // flags
        0x54, 0x03, 0x00, 0x00, // n_mu
        0xd6, 0xb4, 0x73, 0x01, // n_coeffs
        0x3f, 0x06, 0x00, 0x00, // m_max
        0x03, 0x00, 0x00, 0x00, // num_channels
        0x01, 0x00, 0x00, 0x00, // n_bases
        0x00, 0x00, 0x00, 0x00, // metadata bytes
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // num parameters and parameters
        0x00, 0x00, 0x80, 0x3f, // eta
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // alpha * 2
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // unused
    ];

    let header = read_header(&buffer).unwrap();
    let n_mu = header.n_mu;
    assert_eq!(n_mu, 0x0354);
}

#[test]
fn read_fourier_bsdf_test() {
    let path = "../assets/paint.bsdf";
    let table = FourierTable::from_file(path).unwrap();
    println!("mu = {:?}", table.mu);
    // println!("a_offset = {:?}", table.a_offset);
    // println!("m_lookup = {:?}", table.m_lookup);
}

